import { Injectable, InjectionToken, Optional, SkipSelf } from '@angular/core';
import { NgxMatDateAdapter } from './core/date-adapter';
import { NgxDateRange } from './date-selection-model';
import * as i0 from "@angular/core";
import * as i1 from "./core/date-adapter";
/** Injection token used to customize the date range selection behavior. */
export const NGX_MAT_DATE_RANGE_SELECTION_STRATEGY = new InjectionToken('NGX_MAT_DATE_RANGE_SELECTION_STRATEGY');
/** Provides the default date range selection behavior. */
export class DefaultNgxMatCalendarRangeStrategy {
    constructor(_dateAdapter) {
        this._dateAdapter = _dateAdapter;
    }
    selectionFinished(date, currentRange) {
        let { start, end } = currentRange;
        if (start == null) {
            start = date;
        }
        else if (end == null && date && this._dateAdapter.compareDate(date, start) >= 0) {
            end = date;
        }
        else {
            start = date;
            end = null;
        }
        return new NgxDateRange(start, end);
    }
    createPreview(activeDate, currentRange) {
        let start = null;
        let end = null;
        if (currentRange.start && !currentRange.end && activeDate) {
            start = currentRange.start;
            end = activeDate;
        }
        return new NgxDateRange(start, end);
    }
    createDrag(dragOrigin, originalRange, newDate) {
        let start = originalRange.start;
        let end = originalRange.end;
        if (!start || !end) {
            // Can't drag from an incomplete range.
            return null;
        }
        const adapter = this._dateAdapter;
        const isRange = adapter.compareDate(start, end) !== 0;
        const diffYears = adapter.getYear(newDate) - adapter.getYear(dragOrigin);
        const diffMonths = adapter.getMonth(newDate) - adapter.getMonth(dragOrigin);
        const diffDays = adapter.getDate(newDate) - adapter.getDate(dragOrigin);
        if (isRange && adapter.sameDate(dragOrigin, originalRange.start)) {
            start = newDate;
            if (adapter.compareDate(newDate, end) > 0) {
                end = adapter.addCalendarYears(end, diffYears);
                end = adapter.addCalendarMonths(end, diffMonths);
                end = adapter.addCalendarDays(end, diffDays);
            }
        }
        else if (isRange && adapter.sameDate(dragOrigin, originalRange.end)) {
            end = newDate;
            if (adapter.compareDate(newDate, start) < 0) {
                start = adapter.addCalendarYears(start, diffYears);
                start = adapter.addCalendarMonths(start, diffMonths);
                start = adapter.addCalendarDays(start, diffDays);
            }
        }
        else {
            start = adapter.addCalendarYears(start, diffYears);
            start = adapter.addCalendarMonths(start, diffMonths);
            start = adapter.addCalendarDays(start, diffDays);
            end = adapter.addCalendarYears(end, diffYears);
            end = adapter.addCalendarMonths(end, diffMonths);
            end = adapter.addCalendarDays(end, diffDays);
        }
        return new NgxDateRange(start, end);
    }
    /** @nocollapse */ static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.1", ngImport: i0, type: DefaultNgxMatCalendarRangeStrategy, deps: [{ token: i1.NgxMatDateAdapter }], target: i0.ɵɵFactoryTarget.Injectable }); }
    /** @nocollapse */ static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.1", ngImport: i0, type: DefaultNgxMatCalendarRangeStrategy }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.1", ngImport: i0, type: DefaultNgxMatCalendarRangeStrategy, decorators: [{
            type: Injectable
        }], ctorParameters: () => [{ type: i1.NgxMatDateAdapter }] });
/** @docs-private */
export function NGX_MAT_CALENDAR_RANGE_STRATEGY_PROVIDER_FACTORY(parent, adapter) {
    return parent || new DefaultNgxMatCalendarRangeStrategy(adapter);
}
export const NGX_MAT_CALENDAR_RANGE_STRATEGY_PROVIDER = {
    provide: NGX_MAT_DATE_RANGE_SELECTION_STRATEGY,
    deps: [[new Optional(), new SkipSelf(), NGX_MAT_DATE_RANGE_SELECTION_STRATEGY], NgxMatDateAdapter],
    useFactory: NGX_MAT_CALENDAR_RANGE_STRATEGY_PROVIDER_FACTORY,
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZS1yYW5nZS1zZWxlY3Rpb24tc3RyYXRlZ3kuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9kYXRldGltZS1waWNrZXIvc3JjL2xpYi9kYXRlLXJhbmdlLXNlbGVjdGlvbi1zdHJhdGVneS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQW1CLFVBQVUsRUFBRSxjQUFjLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNoRyxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUN4RCxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sd0JBQXdCLENBQUM7OztBQUV0RCwyRUFBMkU7QUFDM0UsTUFBTSxDQUFDLE1BQU0scUNBQXFDLEdBQUcsSUFBSSxjQUFjLENBRXJFLHVDQUF1QyxDQUFDLENBQUM7QUEyQzNDLDBEQUEwRDtBQUUxRCxNQUFNLE9BQU8sa0NBQWtDO0lBQzdDLFlBQW9CLFlBQWtDO1FBQWxDLGlCQUFZLEdBQVosWUFBWSxDQUFzQjtJQUFJLENBQUM7SUFFM0QsaUJBQWlCLENBQUMsSUFBTyxFQUFFLFlBQTZCO1FBQ3RELElBQUksRUFBRSxLQUFLLEVBQUUsR0FBRyxFQUFFLEdBQUcsWUFBWSxDQUFDO1FBRWxDLElBQUksS0FBSyxJQUFJLElBQUksRUFBRSxDQUFDO1lBQ2xCLEtBQUssR0FBRyxJQUFJLENBQUM7UUFDZixDQUFDO2FBQU0sSUFBSSxHQUFHLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJLENBQUMsWUFBWSxDQUFDLFdBQVcsQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUM7WUFDbEYsR0FBRyxHQUFHLElBQUksQ0FBQztRQUNiLENBQUM7YUFBTSxDQUFDO1lBQ04sS0FBSyxHQUFHLElBQUksQ0FBQztZQUNiLEdBQUcsR0FBRyxJQUFJLENBQUM7UUFDYixDQUFDO1FBRUQs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Q0FBQztZQUNuRCxLQUFLLEdBQUcsT0FBTyxDQUFDLGlCQUFpQixDQUFDLEtBQUssRUFBRSxVQUFVLENBQUMsQ0FBQztZQUNyRCxLQUFLLEdBQUcsT0FBTyxDQUFDLGVBQWUsQ0FBQyxLQUFLLEVBQUUsUUFBUSxDQUFDLENBQUM7WUFDakQsR0FBRyxHQUFHLE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQyxHQUFHLEVBQUUsU0FBUyxDQUFDLENBQUM7WUFDL0MsR0FBRyxHQUFHLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQyxHQUFHLEVBQUUsVUFBVSxDQUFDLENBQUM7WUFDakQsR0FBRyxHQUFHLE9BQU8sQ0FBQyxlQUFlLENBQUMsR0FBRyxFQUFFLFFBQVEsQ0FBQyxDQUFDO1FBQy9DLENBQUM7UUFFRCxPQUFPLElBQUksWUFBWSxDQUFJLEtBQUssRUFBRSxHQUFHLENBQUMsQ0FBQztJQUN6QyxDQUFDO2lJQXRFVSxrQ0FBa0M7cUlBQWxDLGtDQUFrQzs7MkZBQWxDLGtDQUFrQztrQkFEOUMsVUFBVTs7QUEwRVgsb0JBQW9CO0FBQ3BCLE1BQU0sVUFBVSxnREFBZ0QsQ0FDOUQsTUFBaUQsRUFDakQsT0FBbUM7SUFFbkMsT0FBTyxNQUFNLElBQUksSUFBSSxrQ0FBa0MsQ0FBQyxPQUFPLENBQUMsQ0FBQztBQUNuRSxDQUFDO0FBRUQsTUFBTSxDQUFDLE1BQU0sd0NBQXdDLEdBQW9CO0lBQ3ZFLE9BQU8sRUFBRSxxQ0FBcUM7SUFDOUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxJQUFJLFFBQVEsRUFBRSxFQUFFLElBQUksUUFBUSxFQUFFLEVBQUUscUNBQXFDLENBQUMsRUFBRSxpQkFBaUIsQ0FBQztJQUNsRyxVQUFVLEVBQUUsZ0RBQWdEO0NBQzdELENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBGYWN0b3J5UHJvdmlkZXIsIEluamVjdGFibGUsIEluamVjdGlvblRva2VuLCBPcHRpb25hbCwgU2tpcFNlbGYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgTmd4TWF0RGF0ZUFkYXB0ZXIgfSBmcm9tICcuL2NvcmUvZGF0ZS1hZGFwdGVyJztcclxuaW1wb3J0IHsgTmd4RGF0ZVJhbmdlIH0gZnJvbSAnLi9kYXRlLXNlbGVjdGlvbi1tb2RlbCc7XHJcblxyXG4vKiogSW5qZWN0aW9uIHRva2VuIHVzZWQgdG8gY3VzdG9taXplIHRoZSBkYXRlIHJhbmdlIHNlbGVjdGlvbiBiZWhhdmlvci4gKi9cclxuZXhwb3J0IGNvbnN0IE5HWF9NQVRfREFURV9SQU5HRV9TRUxFQ1RJT05fU1RSQVRFR1kgPSBuZXcgSW5qZWN0aW9uVG9rZW48XHJcbiAgTmd4TWF0RGF0ZVJhbmdlU2VsZWN0aW9uU3RyYXRlZ3k8YW55PlxyXG4+KCdOR1hfTUFUX0RBVEVfUkFOR0VfU0VMRUNUSU9OX1NUUkFURUdZJyk7XHJcblxyXG4vKiogT2JqZWN0IHRoYXQgY2FuIGJlIHByb3ZpZGVkIGluIG9yZGVyIHRvIGN1c3RvbWl6ZSB0aGUgZGF0ZSByYW5nZSBzZWxlY3Rpb24gYmVoYXZpb3IuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgTmd4TWF0RGF0ZVJhbmdlU2VsZWN0aW9uU3RyYXRlZ3k8RD4ge1xyXG4gIC8qKlxyXG4gICAqIENhbGxlZCB3aGVuIHRoZSB1c2VyIGhhcyBmaW5pc2hlZCBzZWxlY3RpbmcgYSB2YWx1ZS5cclxuICAgKiBAcGFyYW0gZGF0ZSBEYXRlIHRoYXQgd2FzIHNlbGVjdGVkLiBXaWxsIGJlIG51bGwgaWYgdGhlIHVzZXIgY2xlYXJlZCB0aGUgc2VsZWN0aW9uLlxyXG4gICAqIEBwYXJhbSBjdXJyZW50UmFuZ2UgUmFuZ2UgdGhhdCBpcyBjdXJyZW50bHkgc2hvdyBpbiB0aGUgY2FsZW5kYXIuXHJcbiAgICogQHBhcmFtIGV2ZW50IERPTSBldmVudCB0aGF0IHRyaWdnZXJlZCB0aGUgc2VsZWN0aW9uLiBDdXJyZW50bHkgb25seSBjb3JyZXNwb25kcyB0byBhIGBjbGlja2BcclxuICAgKiAgICBldmVudCwgYnV0IGl0IG1heSBnZXQgZXhwYW5kZWQgaW4gdGhlIGZ1dHVyZS5cclxuICAgKi9cclxuICBzZWxlY3Rpb25GaW5pc2hlZChkYXRlOiBEIHwgbnVsbCwgY3VycmVudFJhbmdlOiBOZ3hEYXRlUmFuZ2U8RD4sIGV2ZW50OiBFdmVudCk6IE5neERhdGVSYW5nZTxEPjtcclxuXHJcbiAgLyoqXHJcbiAgICogQ2FsbGVkIHdoZW4gdGhlIHVzZXIgaGFzIGFjdGl2YXRlZCBhIG5ldyBkYXRlIChlLmcuIGJ5IGhvdmVyaW5nIG92ZXJcclxuICAgKiBpdCBvciBtb3ZpbmcgZm9jdXMpIGFuZCB0aGUgY2FsZW5kYXIgdHJpZXMgdG8gZGlzcGxheSBhIGRhdGUgcmFuZ2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gYWN0aXZlRGF0ZSBEYXRlIHRoYXQgdGhlIHVzZXIgaGFzIGFjdGl2YXRlZC4gV2lsbCBiZSBudWxsIGlmIHRoZSB1c2VyIG1vdmVkXHJcbiAgICogICAgZm9jdXMgdG8gYW4gZWxlbWVudCB0aGF0J3Mgbm8gYSBjYWxlbmRhciBjZWxsLlxyXG4gICAqIEBwYXJhbSBjdXJyZW50UmFuZ2UgUmFuZ2UgdGhhdCBpcyBjdXJyZW50bHkgc2hvd24gaW4gdGhlIGNhbGVuZGFyLlxyXG4gICAqIEBwYXJhbSBldmVudCBET00gZXZlbnQgdGhhdCBjYXVzZWQgdGhlIHByZXZpZXcgdG8gYmUgY2hhbmdlZC4gV2lsbCBiZSBlaXRoZXIgYVxyXG4gICAqICAgIGBtb3VzZWVudGVyYC9gbW91c2VsZWF2ZWAgb3IgYGZvY3VzYC9gYmx1cmAgZGVwZW5kaW5nIG9uIGhvdyB0aGUgdXNlciBpcyBuYXZpZ2F0aW5nLlxyXG4gICAqL1xyXG4gIGNyZWF0ZVByZXZpZXcoYWN0aXZlRGF0ZTogRCB8IG51bGwsIGN1cnJlbnRSYW5nZTogTmd4RGF0ZVJhbmdlPEQ+LCBldmVudDogRXZlbnQpOiBOZ3hEYXRlUmFuZ2U8RD47XHJcblxyXG4gIC8qKlxyXG4gICAqIENhbGxlZCB3aGVuIHRoZSB1c2VyIGhhcyBkcmFnZ2VkIGEgZGF0ZSBpbiB0aGUgY3VycmVudGx5IHNlbGVjdGVkIHJhbmdlIHRvIGFub3RoZXJcclxuICAgKiBkYXRlLiBSZXR1cm5zIHRoZSBkYXRlIHVwZGF0ZWQgcmFuZ2UgdGhhdCBzaG91bGQgcmVzdWx0IGZyb20gdGhpcyBpbnRlcmFjdGlvbi5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBkYXRlT3JpZ2luIFRoZSBkYXRlIHRoZSB1c2VyIHN0YXJ0ZWQgZHJhZ2dpbmcgZnJvbS5cclxuICAgKiBAcGFyYW0gb3JpZ2luYWxSYW5nZSBUaGUgb3JpZ2luYWxseSBzZWxlY3RlZCBkYXRlIHJhbmdlLlxyXG4gICAqIEBwYXJhbSBuZXdEYXRlIFRoZSBjdXJyZW50bHkgdGFyZ2V0ZWQgZGF0ZSBpbiB0aGUgZHJhZyBvcGVyYXRpb24uXHJcbiAgICogQHBhcmFtIGV2ZW50IERPTSBldmVudCB0aGF0IHRyaWdnZXJlZCB0aGUgdXBkYXRlZCBkcmFnIHN0YXRlLiBXaWxsIGJlXHJcbiAgICogICAgIGBtb3VzZWVudGVyYC9gbW91c2V1cGAgb3IgYHRvdWNobW92ZWAvYHRvdWNoZW5kYCBkZXBlbmRpbmcgb24gdGhlIGRldmljZSB0eXBlLlxyXG4gICAqL1xyXG4gIGNyZWF0ZURyYWc/KFxyXG4gICAgZHJhZ09yaWdpbjogRCxcclxuICAgIG9yaWdpbmFsUmFuZ2U6IE5neERhdGVSYW5nZTxEPixcclxuICAgIG5ld0RhdGU6IEQsXHJcbiAgICBldmVudDogRXZlbnQsXHJcbiAgKTogTmd4RGF0ZVJhbmdlPEQ+IHwgbnVsbDtcclxufVxyXG5cclxuLyoqIFByb3ZpZGVzIHRoZSBkZWZhdWx0IGRhdGUgcmFuZ2Ugc2VsZWN0aW9uIGJlaGF2aW9yLiAqL1xyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBEZWZhdWx0Tmd4TWF0Q2FsZW5kYXJSYW5nZVN0cmF0ZWd5PEQ+IGltcGxlbWVudHMgTmd4TWF0RGF0ZVJhbmdlU2VsZWN0aW9uU3RyYXRlZ3k8RD4ge1xyXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgX2RhdGVBZGFwdGVyOiBOZ3hNYXREYXRlQWRhcHRlcjxEPikgeyB9XHJcblxyXG4gIHNlbGVjdGlvbkZpbmlzaGVkKGRhdGU6IEQsIGN1cnJlbnRSYW5nZTogTmd4RGF0ZVJhbmdlPEQ+KSB7XHJcbiAgICBsZXQgeyBzdGFydCwgZW5kIH0gPSBjdXJyZW50UmFuZ2U7XHJcblxyXG4gICAgaWYgKHN0YXJ0ID09IG51bGwpIHtcclxuICAgICAgc3RhcnQgPSBkYXRlO1xyXG4gICAgfSBlbHNlIGlmIChlbmQgPT0gbnVsbCAmJiBkYXRlICYmIHRoaXMuX2RhdGVBZGFwdGVyLmNvbXBhcmVEYXRlKGRhdGUsIHN0YXJ0KSA+PSAwKSB7XHJcbiAgICAgIGVuZCA9IGRhdGU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBzdGFydCA9IGRhdGU7XHJcbiAgICAgIGVuZCA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG5ldyBOZ3hEYXRlUmFuZ2U8RD4oc3RhcnQsIGVuZCk7XHJcbiAgfVxyXG5cclxuICBjcmVhdGVQcmV2aWV3KGFjdGl2ZURhdGU6IEQgfCBudWxsLCBjdXJyZW50UmFuZ2U6IE5neERhdGVSYW5nZTxEPikge1xyXG4gICAgbGV0IHN0YXJ0OiBEIHwgbnVsbCA9IG51bGw7XHJcbiAgICBsZXQgZW5kOiBEIHwgbnVsbCA9IG51bGw7XHJcblxyXG4gICAgaWYgKGN1cnJlbnRSYW5nZS5zdGFydCAmJiAhY3VycmVudFJhbmdlLmVuZCAmJiBhY3RpdmVEYXRlKSB7XHJcbiAgICAgIHN0YXJ0ID0gY3VycmVudFJhbmdlLnN0YXJ0O1xyXG4gICAgICBlbmQgPSBhY3RpdmVEYXRlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBuZXcgTmd4RGF0ZVJhbmdlPEQ+KHN0YXJ0LCBlbmQpO1xyXG4gIH1cclxuXHJcbiAgY3JlYXRlRHJhZyhkcmFnT3JpZ2luOiBELCBvcmlnaW5hbFJhbmdlOiBOZ3hEYXRlUmFuZ2U8RD4sIG5ld0RhdGU6IEQpIHtcclxuICAgIGxldCBzdGFydCA9IG9yaWdpbmFsUmFuZ2Uuc3RhcnQ7XHJcbiAgICBsZXQgZW5kID0gb3JpZ2luYWxSYW5nZS5lbmQ7XHJcblxyXG4gICAgaWYgKCFzdGFydCB8fCAhZW5kKSB7XHJcbiAgICAgIC8vIENhbid0IGRyYWcgZnJvbSBhbiBpbmNvbXBsZXRlIHJhbmdlLlxyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBhZGFwdGVyID0gdGhpcy5fZGF0ZUFkYXB0ZXI7XHJcblxyXG4gICAgY29uc3QgaXNSYW5nZSA9IGFkYXB0ZXIuY29tcGFyZURhdGUoc3RhcnQsIGVuZCkgIT09IDA7XHJcbiAgICBjb25zdCBkaWZmWWVhcnMgPSBhZGFwdGVyLmdldFllYXIobmV3RGF0ZSkgLSBhZGFwdGVyLmdldFllYXIoZHJhZ09yaWdpbik7XHJcbiAgICBjb25zdCBkaWZmTW9udGhzID0gYWRhcHRlci5nZXRNb250aChuZXdEYXRlKSAtIGFkYXB0ZXIuZ2V0TW9udGgoZHJhZ09yaWdpbik7XHJcbiAgICBjb25zdCBkaWZmRGF5cyA9IGFkYXB0ZXIuZ2V0RGF0ZShuZXdEYXRlKSAtIGFkYXB0ZXIuZ2V0RGF0ZShkcmFnT3JpZ2luKTtcclxuXHJcbiAgICBpZiAoaXNSYW5nZSAmJiBhZGFwdGVyLnNhbWVEYXRlKGRyYWdPcmlnaW4sIG9yaWdpbmFsUmFuZ2Uuc3RhcnQpKSB7XHJcbiAgICAgIHN0YXJ0ID0gbmV3RGF0ZTtcclxuICAgICAgaWYgKGFkYXB0ZXIuY29tcGFyZURhdGUobmV3RGF0ZSwgZW5kKSA+IDApIHtcclxuICAgICAgICBlbmQgPSBhZGFwdGVyLmFkZENhbGVuZGFyWWVhcnMoZW5kLCBkaWZmWWVhcnMpO1xyXG4gICAgICAgIGVuZCA9IGFkYXB0ZXIuYWRkQ2FsZW5kYXJNb250aHMoZW5kLCBkaWZmTW9udGhzKTtcclxuICAgICAgICBlbmQgPSBhZGFwdGVyLmFkZENhbGVuZGFyRGF5cyhlbmQsIGRpZmZEYXlzKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChpc1JhbmdlICYmIGFkYXB0ZXIuc2FtZURhdGUoZHJhZ09yaWdpbiwgb3JpZ2luYWxSYW5nZS5lbmQpKSB7XHJcbiAgICAgIGVuZCA9IG5ld0RhdGU7XHJcbiAgICAgIGlmIChhZGFwdGVyLmNvbXBhcmVEYXRlKG5ld0RhdGUsIHN0YXJ0KSA8IDApIHtcclxuICAgICAgICBzdGFydCA9IGFkYXB0ZXIuYWRkQ2FsZW5kYXJZZWFycyhzdGFydCwgZGlmZlllYXJzKTtcclxuICAgICAgICBzdGFydCA9IGFkYXB0ZXIuYWRkQ2FsZW5kYXJNb250aHMoc3RhcnQsIGRpZmZNb250aHMpO1xyXG4gICAgICAgIHN0YXJ0ID0gYWRhcHRlci5hZGRDYWxlbmRhckRheXMoc3RhcnQsIGRpZmZEYXlzKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgc3RhcnQgPSBhZGFwdGVyLmFkZENhbGVuZGFyWWVhcnMoc3RhcnQsIGRpZmZZZWFycyk7XHJcbiAgICAgIHN0YXJ0ID0gYWRhcHRlci5hZGRDYWxlbmRhck1vbnRocyhzdGFydCwgZGlmZk1vbnRocyk7XHJcbiAgICAgIHN0YXJ0ID0gYWRhcHRlci5hZGRDYWxlbmRhckRheXMoc3RhcnQsIGRpZmZEYXlzKTtcclxuICAgICAgZW5kID0gYWRhcHRlci5hZGRDYWxlbmRhclllYXJzKGVuZCwgZGlmZlllYXJzKTtcclxuICAgICAgZW5kID0gYWRhcHRlci5hZGRDYWxlbmRhck1vbnRocyhlbmQsIGRpZmZNb250aHMpO1xyXG4gICAgICBlbmQgPSBhZGFwdGVyLmFkZENhbGVuZGFyRGF5cyhlbmQsIGRpZmZEYXlzKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbmV3IE5neERhdGVSYW5nZTxEPihzdGFydCwgZW5kKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKiBAZG9jcy1wcml2YXRlICovXHJcbmV4cG9ydCBmdW5jdGlvbiBOR1hfTUFUX0NBTEVOREFSX1JBTkdFX1NUUkFURUdZX1BST1ZJREVSX0ZBQ1RPUlkoXHJcbiAgcGFyZW50OiBOZ3hNYXREYXRlUmFuZ2VTZWxlY3Rpb25TdHJhdGVneTx1bmtub3duPixcclxuICBhZGFwdGVyOiBOZ3hNYXREYXRlQWRhcHRlcjx1bmtub3duPixcclxuKSB7XHJcbiAgcmV0dXJuIHBhcmVudCB8fCBuZXcgRGVmYXVsdE5neE1hdENhbGVuZGFyUmFuZ2VTdHJhdGVneShhZGFwdGVyKTtcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IE5HWF9NQVRfQ0FMRU5EQVJfUkFOR0VfU1RSQVRFR1lfUFJPVklERVI6IEZhY3RvcnlQcm92aWRlciA9IHtcclxuICBwcm92aWRlOiBOR1hfTUFUX0RBVEVfUkFOR0VfU0VMRUNUSU9OX1NUUkFURUdZLFxyXG4gIGRlcHM6IFtbbmV3IE9wdGlvbmFsKCksIG5ldyBTa2lwU2VsZigpLCBOR1hfTUFUX0RBVEVfUkFOR0VfU0VMRUNUSU9OX1NUUkFURUdZXSwgTmd4TWF0RGF0ZUFkYXB0ZXJdLFxyXG4gIHVzZUZhY3Rvcnk6IE5HWF9NQVRfQ0FMRU5EQVJfUkFOR0VfU1RSQVRFR1lfUFJPVklERVJfRkFDVE9SWSxcclxufTtcclxuIl19