import * as i0 from '@angular/core';
import { Pipe, inject, Injectable, Directive, signal, effect } from '@angular/core';
import IMask from 'imask';
import { DatePipe } from '@angular/common';
import * as i1 from '@ngx-translate/core';
import { TranslateService } from '@ngx-translate/core';
import * as i1$1 from '@angular/platform-browser';
import Swal from 'sweetalert2';
import Scrollbar from 'smooth-scrollbar';
import { HttpClient } from '@angular/common/http';

class Mask {
    static { this.LANG_PT = 'pt-BR'; }
    static { this.LANG_EN = 'en-US'; }
    static { this.LANG_ES = 'es-ES'; }
    static getMaskCnpj() {
        const mask = {
            mask: '00.000.000/0000-00',
            lazy: false,
            placeholderChar: ' '
        };
        return mask;
    }
    static getMaskCpf() {
        const mask = {
            mask: '000.000.000-00',
            lazy: false,
            placeholderChar: ' '
        };
        return mask;
    }
    static getMaskCep() {
        const mask = {
            mask: '00000-000',
            lazy: false,
            placeholderChar: '_'
        };
        return mask;
    }
    static getImaskCurrency(scale = 2, currencyCode = 'BRL') {
        const mask = {
            mask: Number,
            scale: scale,
            thousandsSeparator: currencyCode === 'BRL' ? '.' : ',',
            padFractionalZeros: true,
            normalizeZeros: true,
            radix: currencyCode === 'BRL' ? ',' : '.',
            signed: true
        };
        return mask;
    }
    static getImaskNumber(language, scale, signed) {
        const radix = (scale === 0 ? ' ' : ',');
        if (scale === undefined) {
            scale = 2;
        }
        const mask = {
            mask: Number,
            scale: scale,
            thousandsSeparator: '.',
            padFractionalZeros: true,
            normalizeZeros: true,
            signed: signed,
            radix: radix
        };
        switch (language) {
            case Mask.LANG_PT:
            case Mask.LANG_ES:
                break;
            case Mask.LANG_EN:
                mask.thousandsSeparator = ',',
                    mask.radix = '.';
                break;
            default:
                break;
        }
        return mask;
    }
    static getImaskNumberBigDecimal() {
        const mask = {
            mask: Number,
            scale: 6,
            thousandsSeparator: '.',
            padFractionalZeros: false,
            normalizeZeros: false,
            radix: ',',
        };
        return mask;
    }
    static getImaskLatitudeNumber() {
        const mask = {
            mask: Number,
            scale: 8,
            signed: true,
            thousandsSeparator: '.',
            padFractionalZeros: true,
            normalizeZeros: true,
            radix: ',',
            min: -99,
            max: 99
        };
        return mask;
    }
    static getImaskLongitudeNumber() {
        const mask = {
            mask: Number,
            scale: 8,
            signed: true,
            thousandsSeparator: '.',
            padFractionalZeros: true,
            normalizeZeros: true,
            radix: ',',
            min: -999,
            max: 999
        };
        return mask;
    }
    static getImaskTCelPhone(language) {
        const mask = {
            mask: '(00) 0 0000-0000',
            lazy: false,
            placeholderChar: ' '
        };
        return mask;
    }
    static getImaskTCelPhoneSemDDD(language) {
        const mask = {
            mask: '0 0000-0000',
            lazy: false,
            placeholderChar: ' '
        };
        return mask;
    }
    static getImaskTelephone(language) {
        const mask = {
            mask: '(00) 0000-0000',
            lazy: false,
            placeholderChar: '_'
        };
        switch (language) {
            case 'pt':
                break;
            case 'en':
                break;
            default:
                break;
        }
        return mask;
    }
    static getImaskTelephoneSemDDD(language) {
        const mask = {
            mask: '0000-0000',
            lazy: false,
            placeholderChar: ' '
        };
        switch (language) {
            case 'pt':
                break;
            case 'en':
                break;
            default:
                break;
        }
        return mask;
    }
    static getMaskHourMinute() {
        const mask = {
            mask: '00:00:00',
            lazy: false,
            placeholderChar: ' '
        };
        return mask;
    }
    static getMaskDate() {
        const mask = {
            mask: '00/00/0000',
            lazy: false,
            placeholderChar: ' '
        };
        return mask;
    }
    static getMaskIp() {
        const mask = {
            mask: 'IP.IP.IP.IP',
            blocks: {
                IP: {
                    mask: '0[00]',
                    minLength: 1,
                    from: 1,
                    to: 255,
                }
            }
        };
        return mask;
    }
    static getMaskImai() {
        const mask = {
            mask: '000000-00-000000-0',
            lazy: false,
            placeholderChar: ' '
        };
        return mask;
    }
}

class CpfCnpjFormat {
    constructor() {
        this.maskCnpj = IMask.createMask(Mask.getMaskCnpj());
        this.maskCpf = IMask.createMask(Mask.getMaskCpf());
    }
    transform(value) {
        if (value.length === 11) {
            this.maskCpf.resolve(value);
            return this.maskCpf.value;
        }
        else if (value.length === 14) {
            this.maskCnpj.resolve(value);
            return this.maskCnpj.value;
        }
        return '';
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.9", ngImport: i0, type: CpfCnpjFormat, deps: [], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "18.2.9", ngImport: i0, type: CpfCnpjFormat, isStandalone: true, name: "cpfCnpjFormat" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.9", ngImport: i0, type: CpfCnpjFormat, decorators: [{
            type: Pipe,
            args: [{
                    name: 'cpfCnpjFormat',
                    standalone: true
                }]
        }] });

class DateFormatPipe {
    constructor(translateService) {
        this.translateService = translateService;
    }
    transform(value, pattern = 'mediumDate') {
        const datePipe = new DatePipe(this.translateService.currentLang);
        return datePipe.transform(value, pattern);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.9", ngImport: i0, type: DateFormatPipe, deps: [{ token: i1.TranslateService }], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "18.2.9", ngImport: i0, type: DateFormatPipe, isStandalone: true, name: "dateFormat" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.9", ngImport: i0, type: DateFormatPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'dateFormat',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i1.TranslateService }] });

class ReplaceNullWithTextPipe {
    transform(value, repleceText = 'N/A') {
        if (typeof value === 'undefined' || value === null) {
            return repleceText;
        }
        return value;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.9", ngImport: i0, type: ReplaceNullWithTextPipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "18.2.9", ngImport: i0, type: ReplaceNullWithTextPipe, isStandalone: true, name: "replaceNullWithText" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.9", ngImport: i0, type: ReplaceNullWithTextPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'replaceNullWithText',
                    standalone: true
                }]
        }] });

class SafePipe {
    constructor(_sanitizer) {
        this._sanitizer = _sanitizer;
    }
    transform(value, type) {
        switch (type) {
            case 'html':
                return this._sanitizer.bypassSecurityTrustHtml(value);
            case 'style':
                return this._sanitizer.bypassSecurityTrustStyle(value);
            case 'script':
                return this._sanitizer.bypassSecurityTrustScript(value);
            case 'url':
                return this._sanitizer.bypassSecurityTrustUrl(value);
            case 'resourceUrl':
                return this._sanitizer.bypassSecurityTrustResourceUrl(value);
            default:
                throw new Error(`Unable to bypass security for invalid type: ${type}`);
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.9", ngImport: i0, type: SafePipe, deps: [{ token: i1$1.DomSanitizer }], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "18.2.9", ngImport: i0, type: SafePipe, isStandalone: true, name: "safe" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.9", ngImport: i0, type: SafePipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'safe',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i1$1.DomSanitizer }] });

class UtcDatePipe {
    transform(value) {
        if (!value) {
            return '';
        }
        const dateValue = new Date(value);
        const dateWithNoTimezone = new Date(dateValue.getUTCFullYear(), dateValue.getUTCMonth(), dateValue.getUTCDate(), dateValue.getUTCHours(), dateValue.getUTCMinutes(), dateValue.getUTCSeconds());
        return dateWithNoTimezone;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.9", ngImport: i0, type: UtcDatePipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "18.2.9", ngImport: i0, type: UtcDatePipe, isStandalone: true, name: "utcDate" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.9", ngImport: i0, type: UtcDatePipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'utcDate',
                    standalone: true
                }]
        }] });

class AlertService {
    constructor() {
        this.translate = inject(TranslateService);
    }
    alertText(title, message, fnConfirm, fnCancel) {
        Swal.fire({
            title: title,
            text: message,
            icon: 'success',
            confirmButtonColor: '#0CC27E',
            confirmButtonText: '<i class="ft-check-circle"></i> ' + this.translate.instant('OK')
        }).then((result) => {
            if (result.value) {
                fnConfirm();
            }
            else if (fnCancel !== undefined) {
                fnCancel();
            }
        });
    }
    confirmText(title, message, fnConfirm, fnCancel) {
        let mensagem = '';
        let params = {};
        if (message instanceof Array) {
            mensagem = message[0];
            params = message[1];
        }
        else {
            mensagem = message;
        }
        Swal.fire({
            title: title,
            text: mensagem,
            icon: 'question',
            showCancelButton: true,
            confirmButtonColor: '#0CC27E',
            cancelButtonColor: '#FF586B',
            confirmButtonText: '<i class="ft-check-circle"></i> ' + this.translate.instant('SIM'),
            cancelButtonText: '<i class="ft-x-circle"></i> ' + this.translate.instant('NAO'),
        }).then((result) => {
            if (result.value) {
                fnConfirm();
            }
            else if (fnCancel !== undefined) {
                fnCancel();
            }
        });
    }
    confirmTextResetPassword(fnConfirm, fnCancel) {
        const swal = {
            title: this.translate.instant('RESETAR_SENHA'),
            text: this.translate.instant('DIGITE_CODIGO_AUTENTICACAO'),
            icon: 'info',
            input: 'text',
            inputValidator: (value) => {
                return !value && this.translate.instant('CAMPO_OBRIGATORIO');
            },
            showCancelButton: true,
            confirmButtonColor: '#0CC27E',
            cancelButtonColor: '#FF586B',
            cancelButtonText: '<i class="ft-x"></i> ' + this.translate.instant('CANCELAR'),
            confirmButtonText: '<i class="ft-check"></i> ' + this.translate.instant('OK'),
        };
        Swal.fire(swal).then((result) => {
            if (result.value) {
                fnConfirm(result.value);
            }
            else if (fnCancel !== undefined) {
                fnCancel();
            }
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.9", ngImport: i0, type: AlertService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.9", ngImport: i0, type: AlertService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.9", ngImport: i0, type: AlertService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }] });

class SlimscrollDirective {
    constructor(el, renderer) {
        this.el = el;
        this.renderer = renderer;
    }
    ngAfterViewInit() {
        // smooth scroll
        Scrollbar.init(this.el.nativeElement);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.9", ngImport: i0, type: SlimscrollDirective, deps: [{ token: i0.ElementRef }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.2.9", type: SlimscrollDirective, isStandalone: true, selector: "[appSlimScroll]", ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.9", ngImport: i0, type: SlimscrollDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[appSlimScroll]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: i0.Renderer2 }] });

class TranslationService {
    // Getter para o signal, para que o pipe e componentes possam usá-lo
    get currentLanguage() {
        return this.languageSignal;
    }
    get currentLang() {
        return this.languageSignal();
    }
    constructor() {
        this.http = inject(HttpClient);
        this.translations = {};
        // Signal para o idioma atual
        this.languageSignal = signal('pt-BR'); // Define o idioma padrão como inglês
        this.loadTranslations(this.languageSignal());
    }
    use(lang) {
        this.languageSignal.set(lang); // Atualiza o Signal
        this.loadTranslations(lang); // Carrega novas traduções
    }
    // Retorna uma string traduzida com base na chave
    getTranslation(key, params) {
        let translation = this.translations[key] || key; // Retorna a chave se a tradução não for encontrada
        // Substituir parâmetros dinâmicos, se houver
        if (params) {
            Object.keys(params).forEach((param) => {
                translation = translation.replace(`{{${param}}}`, params[param]);
            });
        }
        return translation;
    }
    instant(key, params) {
        return this.getTranslation(key, params);
    }
    loadTranslations(lang) {
        this.http
            .get(`assets/i18n/${lang}.json`)
            .subscribe((translations) => {
            this.translations = translations;
        });
    }
    getBrowserLang() {
        return window.navigator.language;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.9", ngImport: i0, type: TranslationService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.9", ngImport: i0, type: TranslationService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.9", ngImport: i0, type: TranslationService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: () => [] });

class TranslationPipe {
    constructor() {
        this.translationService = inject(TranslationService);
        this.translatedText = ''; // Armazena a tradução atual
        this.currentKey = ''; // Variável para armazenar a chave atual
        // Recalcula a tradução sempre que o idioma mudar
        effect(() => {
            const lang = this.translationService.currentLanguage(); // Observa o Signal
            this.translatedText = this.translationService.instant(this.currentKey);
        });
    }
    transform(key) {
        // Atualizamos a chave de tradução atual
        this.currentKey = key;
        // Obtém a tradução atual
        return this.translationService.instant(key);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.9", ngImport: i0, type: TranslationPipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "18.2.9", ngImport: i0, type: TranslationPipe, isStandalone: true, name: "translate", pure: false }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.9", ngImport: i0, type: TranslationPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'translate',
                    standalone: true,
                    pure: false
                }]
        }], ctorParameters: () => [] });

/*
 * Public API Surface of shared-utils
 */

/**
 * Generated bundle index. Do not edit.
 */

export { AlertService, CpfCnpjFormat, DateFormatPipe, Mask, ReplaceNullWithTextPipe, SafePipe, SlimscrollDirective, TranslationPipe, TranslationService, UtcDatePipe };
//# sourceMappingURL=angulartoolsdr-shared-utils.mjs.map
